{"name":"aeh","tagline":"*scratch*","body":"Errors or exceptional events can occur during the execution of a program. The common idiom to handle exceptions is to return control to the caller function. This is done either by returning an error code or by throwing an exception object. Languages like C++, Java and Python allow the programmer to create an object that contain information about the error. This exception object is then handed over to the runtime system. This is known as throwing the exception. When an exception is thrown, the runtime system start unwinding the call stack, looking for a function with a special block of code that can handle the exception. This code block is called the exception handler. When an exception handler is found, the exception object is handed over to it. This is known as catching the exception. The code block can now decide what to do with the exception. It can retry the failed operation, log the error state, re-throw the exception or just ignore it. This mechanism has some clear advantages. For instance, languages like Java has checked exceptions that make it impossible for caller methods to ignore an exception event. The exception system also helps is separating error-handling code from regular code. But returning control to the caller has some disadvantages as well. The exception handling code might be high above the stack. This means unwinding the whole stack. This may not be the ideal thing to do, when the exceptional situation can be corrected locally. For example, think of a function that makes a socket connection to a remote server:\r\n\r\n```java\r\n// This code is not Java or C#, but\r\n// an illustration.\r\nSocket connect (String hostName, int port) \r\n    throws SocketConnectionError {\r\n    if (!ResolveHost (hostName))\r\n        throw new SocketConnectionError (\r\n              \"Host cannot be resolved.\");\r\n    ....\r\n    return newSocketObject; \r\n}\r\n```\r\n\r\nNow if hostName was input from a UI and the user misspelled it, this function will throw an exception and the whole sequence of function calls has to be started again, while the error can be corrected by directly replacing the value of hostName without leaving the current stack. The exception system used by most languages do not offer this flexibility. Now let us turn our attention to a superior way of dealing with errors: the condition system of Common Lisp.\r\n\r\n## Exception handling in Common Lisp\r\n\r\nBefore plunging into the full depths of the condition system, let us see how Common Lisp allows the handling of exceptions in the traditional way. In Common Lisp exception objects are called Conditions. A new Condition is defined using the define-condition macro. Conditions are sub-types of the error class. This is how a condition to signal socket errors could be defined:\r\n\r\n```lisp\r\n(define-condition socket-connection-error (error)\r\n  ((text :initarg :text :reader text)))\r\n```\r\n\r\nThe constructor of socket-connection-error will take an argument called text that describes the error. Now we can use socket-connection-error in the Common Lisp version of the SocketConnect function:\r\n\r\n```lisp\r\n(defun socket-connect (host port)\r\n  (if (not (resolve-host host))\r\n      (error 'socket-connection-error \r\n         :text \"Failed to resolve host.\"))\r\n ....    \r\n new-socket-object)\r\n```\r\n\r\nThe macro handler-case can be used to implement the Java style exception handling mechanism by unwinding the stack:\r\n\r\n```lisp\r\n(handler-case \r\n  (socket-connect \"www.lisp.org\" 80)\r\n  (socket-connection-error (ex)\r\n  (format t \"error: ~a~%\" (text ex))))\r\n```\r\n\r\nThis is similar to a try-catch block. If socket-connect fails, the socket-connection-error object is caught and the text description of the error is printed to the output stream.\r\n\r\nAnother form used to catch exceptions is restart-case. This is similar to handler-case except that it does not specify any exceptions to be caught. Instead it contain named code blocks that will be executed in case of an error. These code blocks are called restarts.\r\n\r\n```lisp\r\n(defun get-page (host port page)\r\n(restart-case \r\n    (let ((sock (socket-connect host port)))\r\n            (socket-http-get sock page))\r\n  (get-default-content () \r\n    \"Page not found\")))\r\n```\r\n\r\nThe above code handles a socket-connection-error with the help of a restart named get-default-content. It returns a pre-defined HTML encoded message in case of a socket connection error. If this is executed from a Common Lisp shell, the user will land in a debugger, where he will be given a list of restarts that include get-default-content. To evade the debugger and execute a preferred restart directly, we can use the handler-bind macro:\r\n\r\n```lisp\r\n(handler-bind ((socket-connection-error\r\n              #'(lambda (ex)\r\n                  (invoke-restart\r\n                    'get-default-content))))\r\n(get-page \"www.lisp.org\" 80 \"/\"))\r\n```\r\n\r\nhandler-bind take two forms as arguments. The first form contain exception handler functions. The above code explicitly invokes the get-default-content restart. To the end user, this looks as if the get-page call has succeeded and returned valid HTML. Restarts are what makes the Common Lisp condition system special. With the help of restarts exceptions can be handled without unwinding the stack. Restarts also allow functions to expose a list of error handling policies. This give callers the opportunity to choose one error handling strategy over another. Let us study this in detail.\r\nError handling policies\r\n\r\nError handling policies are implemented by providing more than one restart. Here is a new version of get-page that expose three policies: one that returns a default HTML document, another that will return the value passed by the caller and yet another that simply prints the exception message. A caller can choose any one that suits his need:\r\n\r\n```lisp\r\n(defun get-page (host port page)\r\n  (restart-case \r\n    (let ((sock (socket-connect host port)))\r\n            (socket-http-get sock page))\r\n  (get-default-content () \r\n   \"Page not found\")\r\n  (use-value (v) v)\r\n  (print-error (ex) \r\n    (format t \"Error: ~a~%\" (text ex)))))\r\n```\r\n\r\nSomeone that opts to pass in a user defined HTML document on a socket connection error can call get-page like this:\r\n\r\n```lisp\r\n(handler-bind ((socket-connection-error\r\n              #'(lambda (ex)\r\n                  (invoke-restart 'use-value\r\n    \"Network error!\"))))\r\n(get-page \"www.lisp.org\" 80 \"/\"))\r\n```\r\n\r\nIt is even possible to make the restart read a value from the end user, so that exception handling becomes more interactive:\r\n\r\n```lisp\r\n;; more restarts\r\n(defun get-page (host port page)\r\n  (restart-case \r\n   (let ((sock (socket-connect host port)))\r\n            (socket-http-get sock page))\r\n     (get-default-content () \"hello, world\")\r\n     (use-value (v) \r\n       :report \"Specify HTML to return\"\r\n       :interactive (lambda () (list (read)))\r\n     v)\r\n  (print-error (ex) (format t \"Error: ~a~%\" (text ex)))))\r\n```\r\n\r\nThe debugger will provide the user with the prompt \"Specify HTML to return\" where he can specify the value to be returned by get-page. (Asking the user to type in HTML will not be a pleasant UI experience, though!)\r\n\r\nThe following updated version of get-page makes the interactive restart feature more practical. It gives the user an option to specify a new URL to connect to. A connection is attempted until success. The exception is fixed just were it occurred, without losing context:\r\n\r\n```lisp\r\n(defun get-page (host port page)\r\n  (loop\r\n    (restart-case \r\n        (let ((sock (socket-connect host port)))\r\n              (return (socket-http-get sock page)))\r\n    (use-value (v) (setf host v)))))\r\n```\r\n\r\nA user level function can now retry the connection from the get-page stack itself:\r\n```lisp\r\n(defun download-page (url page)\r\n  (handler-bind \r\n    ((socket-connection-error\r\n      #'(lambda (ex) \r\n          (invoke-restart 'use-value \r\n           (progn\r\n            (format t \"Connection failed. Enter a new URL:\")\r\n            (list (read)))))))\r\n   (get-page url 80 page)))\r\n```\r\n\r\n## More than handling errors!\r\n\r\nThe scope of the condition system is not limited to error handling. We can build signalling protocols on top of this so that functions can interact with each other in complex ways. The error function we used to raise a condition is built on top of a primitive called signal. This can be called directly to use conditions as a communication mechanism between functions. The following example shows how signal can be used to interleave execution of two functions:\r\n\r\n```lisp\r\n(define-condition hand-over-control (error) nil)\r\n  (defun f ()\r\n   (format t \"f1 \")\r\n   (signal (make-condition 'hand-over-control))\r\n   (format t \"f2 \"))\r\n\r\n  (defun g ()\r\n   (handler-bind\r\n    ((hand-over-control #'(lambda (hand-over-control-object)\r\n                        (format t \"g1 \"))))\r\n   (f))\r\n   (format t \"g2~%\"))\r\n```\r\n\r\nA call to g will produce the following output:\r\n\r\n```lisp\r\n> (g)\r\n   f1 g1 f2 g2\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}