<!DOCTYPE html>
<html>

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="../stylesheets/w3.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
  <link rel="stylesheet" href="../stylesheets/font-awesome.min.css">
  <link rel="stylesheet" href="../stylesheets/style.css">
  <link rel="stylesheet" href="./style.css">
  <title>Vijay Mathew / Blog / A URL Shortening Service</title>
  </head>

  <body>

    <!-- !PAGE CONTENT! -->
    <div class="w3-content" style="max-width:1100px">

      <!-- Header -->
      <header class="w3-panel w3-center w3-opacity" style="padding:50px 16px">
	<h1 class="w3-xlarge">A URL Shortening Service</h1>

	<div class="w3-bar w3-border">
	  <a href="./index.html" class="w3-bar-item w3-button">home</a>
	  <a href="mailto:mathew.vijay@gmail.com" class="w3-bar-item w3-button w3-hide-small">email</a>
	</div>
      </header>

      <p class="published">2018-February-10</p>
    
    <p>I recently came across <a href="http://sparkjava.com/" target="_blank">Spark</a>, a micro framework for developing web applications for the JVM.
      I decided to try it out from Clojure by writing a
      <a href="https://en.wikipedia.org/wiki/URL_shortening" target="_blank">URL shortening service.</a>
      This post will walk you through the actual implementation of the service. In that proecess, we will create a Clojure wrapper for Spark's programming
      interface. We will also explore some ideas around configuring and scaling the service.</p>

    <h3>An Algorithm for Shortening URLs</h3>
    
    <p>The technique for shortening a long URL is quite simple &hyphen; convert the hash of the URL
      to a base-62 value. This is accomplished by the following code:</p>

        <div class="prog">
      <pre><code>
(<span class="kw">def</span> <span class="pw">^String</span> base62-lookup <span class="str">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)

(<span class="kw">defn</span> decimal->b62
  [n]
  (<span class="kw">loop</span> [n n, rs []]
    (<span class="kw">if</span> (zero? n)
      (clojure.string/join (reverse rs))
      (<span class="kw">let</span> [[q r] [(quot n 62) (rem n 62)]]
        (<span class="kw">recur</span> q (conj rs (.charAt base62-lookup (Math/abs r))))))))

(<span class="kw">defn</span> encode
  [<span class="pw">^String</span> url]
  (decimal->b62 (.hashCode url)))
      </code></pre>
        </div>

    <p>Calling <code>encode</code> on a URL will return the shortened version of it:</p>
    <div class="prog">
      <pre><code>
<b>user&gt;</b> (encode <span class="str">"http://sparkjava.com/documentation"</span>)
<span class="comment">;; "AuV1V"</span>
      </code></pre>
    </div>
    
    <h3>Implementing the Web Service</h3>

    <p>The service exposes two HTTP API endpoints. One is for shortening a URL. This endpoint will internally invoke the <code>encode</code>
      function that was defined in the preceding section.
      The second endpoint will receive a value generated by <code>encode</code> and return a
      <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections" target="_blank">redirect</a> to the original URL.
      Here is the specification for the API:</p>

    <div class="prog">
      <pre><code>
<span class="kw">POST</span> /
<b>Request</b>:          
  Content-Type: application/json
  Body: {"url": "a_url"}
<b>Response on Success</b>:
  Status: 200 OK
  Content-Type: application/json
  Body: {"hash": "hash_of_url"}

<span class="kw">GET</span> /:hash
<b>Response on Success</b>:
  Status: 302 Found
  Location: "original_url_from_which_hash_was_generated"
<b>Response if :hash was not generated here</b>:
  Status: 404 Not found
      </code></pre>
    </div>

    <p>A Spark application uses a set of <em>routes</em> to declare its public interface. The HTTP API that we described above can be
      implemented with the <code>post</code> and <code>get</code> routes:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">defn</span> -main
  []
  (Spark/post <span class="str">"/"</span> (make-handler post-handler))
  (Spark/get <span class="str">"/:hash"</span> (make-handler get-handler)))
      </pre></code>
    </div>

    <p>A route has three components &hyphen; the HTTP verb (get, post, put etc), a path (<code>"/"</code>, <code>"/:hash"</code>) and a handler.
      The handler must be an implementation of a Java interface named <code>Route</code>. This interface has a single method called <code>handle</code>
      which is invoked to process a client request and generate a response. The convenience function
      <code>make-handler</code> is used to generate an implementation of <code>Route</code>. This takes the actual handler function as argument
      and arranges the <code>Route</code>'s <code>handle</code> method to call it.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">defn</span> make-handler
  [f]
  (<span class="kw">reify</span> Route
    (handle [_ ^Request request ^Response response]
       (f request response))))
      </code></pre>
    </div>

    <p>The <code>Request</code> object contains information
      about the HTTP request, like its headers, content type, body etc. The <code>Response</code> object expose methods that the handler can
      call to generate a valid HTTP response.</p>
    <p>Now we can proceed to implement the handler functions themselves. First, we will define the handler for the <code>POST</code>
      request. This handler will read the JSON encoded request body, parse it to extract the URL and generate the base62 hash of the URL.
      This hash is then send back in the response.
      The function will also map the hash to the original URL in an in-memory lookup table.
      The initial implementation of the <code>POST</code> handler is shown below:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">def</span> db (atom {}))

(<span class="kw">defn</span> post-handler
  [request response]
  (let [r (<a href="https://github.com/dakrone/cheshire" target="_blank">cheshire.core</a>/parse-string (<span class="pw">.body</span> request) <span class="kw">true</span>)
        url (<span class="pw">:url</span> r)
        short-url (encode url)]
    (swap! db assoc short-url url)
    (<span class="pw">.status</span> response 200)
    (<span class="pw">.header</span> response <span class="str">"Content-Type" "application/json"</span>)
    (cheshire.core/generate-string {<span class="pw">:hash</span> short-url})))
      </code></pre>
    </div>

    <p>The <code>GET</code> handler receives a hash (or short-url) as input. This hash will be used as the key to query the lookup table.
      If a URL is found mapped to this key, a redirect is generated for this URL. If no mapping is found,
      an HTTP 404 (Not Found) response is returned.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">defn</span> get-handler
  [request response]
  (<span class="kw">if-let</span> [url (get @db (<span class="pw">.params</span> request <span class="str">":hash"</span>))]
    (<span class="pw">.redirect</span> response url)
    (<span class="pw">.status</span> response 404)))
      </code></pre>
    </div>

    <p>The first version of the URL shortening service is ready! You can download the complete project <a href="./code/url_shortner01.zip">here</a>.
      Execute <code>lein run</code> from the extracted project folder. The service should come up and start listening for incoming
      HTTP requests on port <code>4567</code>. Here are a few <code><a href="https://curl.haxx.se/" target="_blank">curl</a></code>
      sessions to test the service:</p>

    <div class="prog">
      <pre><code>
$ curl -v -X POST -d '{"url": "http://sparkjava.com/documentation#getting-started"}'\
  -H 'Content-Type: application/json' 'http://localhost:4567'

<span class="comment">HTTP/1.1 200 OK          
{"shortUrl":"1BqMVO"}</span>

$ curl -v 'http://localhost:4567/1BqMVO'

<span class="comment">HTTP/1.1 302 Found
Location: http://sparkjava.com/documentation#getting-started</span>
      </code></pre>
    </div>

    <h3>Adding Storage</h3>

    <p>One problem with the current implementation is that the hash->url mappings are stored in the memory of the service itself.
      If the JVM is shutdown, all data is lost and the users of the service will not be very happy :-). Moreover,
      it becomes impossible to scale the service by running multiple instances behind a load-balancer.
      So it is necessary to add a storage that can be shared by multiple instances of the service.
      This could be an RDBMS server like MySQL or a key-value store like Couchbase. I will use Couchbase for this example.</p>
    <p>It is straightforward to make the service to talk to a data store like Couchbase, which just maps a string key to a string value.
      This model is similar to the one used by the current in-memory store.
      We can add a <code>store</code> abstraction to the service which internally uses
      the <a href="https://github.com/otabat/couchbase-clj" target="_blank">Couchbase client library for Clojure</a> to talk to a Couchbase cluster:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">ns</span> url-shortner.store
  (<span class="pw">:require</span> [couchbase-clj.client :as cb]))

(<span class="kw">defn</span> open-connection
  [props]
  (cb/create-client props))

(<span class="kw">defn</span> close-connection
  [conn]
  (when conn
    (cb/shutdown conn)))

(<span class="kw">defn</span> set-data
  [conn k v]
  (cb/set conn k v))

(<span class="kw">defn</span> get-data
  [conn k]
  (cb/get conn k))
      </code></pre>
    </div>

    <p>The <code>props</code> argument passed to <code>open-connection</code> is a Clojure map that specifies the configuration (username, server urls etc)
      required to connect to the Couchbase cluster. This configuration may change from one deployment site to another. That means, we need our service
      to be able to dynamically load site-specific configuration information. An easy way to manage configuration is to encode it in
      <a href="https://github.com/edn-format/edn" target="_blank">EDN format</a>. This will allow the application to reuse
      Clojure's built-in reader and parser to load and decode the configuration, as shown below:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">def</span> config (read-string (slurp <span class="str">"./config.edn"</span>)))

(<span class="kw">def</span> db (store/open-connection (<span class="pw">:store</span> config)))    
      </code></pre>
    </div>

    <p>The contents of the configuration file is:</p>

    <div class="prog">
      <pre><code>
<span class="comment">;; config.edn</span>
          
{<span class="pw">:web-server-port</span> 8000
 <span class="pw">:store</span>
 {<span class="pw">:username</span> <span class="str">"Administrator"</span>
  <span class="pw">:bucket</span> <span class="str">"default"</span>
  <span class="pw">:uris</span> [<span class="str">"http://localhost:8091/pools"</span>]}}
      </code></pre>
    </div>

    <p>Note that we have made the port on which the service listens for incoming requests configurable as well.</p>

    <p>Now we should update <code>post-handler</code> to store the mapping in the remote store:</p>

    <div class="prog">
      <pre><code>
(store/set-data db short-url url)
      </code></pre>
    </div>

    <p><code>get-handler</code> can lookup its response as:</p>
    <div class="prog">
      <pre><code>
(store/get-data db (<span class="pw">.params</span> request <span class="str">":hash"</span>))]
      </code></pre>
    </div>

    <p>The <code>-main</code> function has to be updated to start the server on the configured port:</p>

    <div class="prog">
      <pre><code>
(Spark/port (<span class="pw">:web-server-port</span> config))
      </code></pre>
    </div>

    <h3>Simplifying the Programming Interface</h3>

    <p>Spark is not a framework designed with Clojure in mind. So it's a good idea to write a simpler and more idiomatic Clojure
      interface on top of Spark. This interface should expose the <code>Request</code> and <code>Response</code> objects as native
      Clojure data structures. The route specification should directly accept functions instead of implementations of the <code>Route</code> interface.
      The handlers should also be more functional in their behavior &hyphen; accept a request map and return a response map.</p>

    <p>I wrote a <a href="./code/spark.clj">Clojure wrapper for Spark</a> that does all this.
      It provides enough abstractions for the web layer to be re-written in better Clojure style.</p>

    <p>The code for the new web layer that makes use of this wrapper is reproduced below:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">ns</span> url-shortner.core
  (<span class="pw">:require</span> [cheshire.core <span class="pw">:as</span> json]
            [url-shortner.encoder <span class="pw">:as</span> e]
            [url-shortner.spark <span class="pw">:refer :all</span>]
            [url-shortner.store <span class="pw">:as</span> store]))

(<span class="kw">def</span> config (read-string (slurp <span class="str">"./config.edn"</span>)))

(<span class="kw">def</span> db (store/open-connection (<span class="pw">:store</span> config)))

(<span class="kw">defn</span> post-handler
  [request]
  (<span class="kw">let</span> [r (json/parse-string (<span class="pw">:body</span> request) <span class="pw">true</span>)
        url (<span class="pw">:url</span> r)
        short-url (e/encode url)]
    (store/set-data db short-url url)
    {<span class="pw">:status</span> 200
     <span class="pw">:headers</span> {<span class="pw">:Content-Type</span> <span class="str">"application/json"</span>}
     <span class="pw">:body</span> (json/generate-string {<span class="pw">:hash</span> short-url})}))

(<span class="kw">defn</span> get-handler
  [request]
  (<span class="kw">if-let</span> [url (store/get-data db (<span class="pw">:hash</span> (<span class="pw">:params</span> request)))]
    {<span class="pw">:status</span> 302
     <span class="pw">:headers</span> {<span class="pw">:Location</span> url}}
    {<span class="pw">:status</span> 404
     <span class="pw">:body</span> <span class="str">"Not Found"</span>}))

(<span class="kw">defn</span> -main
  []
  (port! (<span class="pw">:web-server-port</span> config))

  (GET <span class="str">"/:hash"</span> get-handler)
  (POST <span class="str">"/"</span> post-handler))
      </code></pre>
    </div>

    <p>The application code no longer has to deal directly with low-level Java abstractions. Instead all request handling is implemented using
      first-class Clojure data structures and functions.</p>

    <p>The complete source code for the updated service can be downloaded <a href="./code/url_shortner02.zip">here</a>.
      Now you can start multiple instances of the service, by configuring a unique port number for each. Also make sure the
      <code>:store</code> configuration can connect the service to a running Couchbase cluster.
      You can distribute POST and GET requests across these instances and see them serving the requests from data in
      the shared data store.</p>

    <h3>Load-balancing and Scaling</h3>

    <p>Let us finish this post by automating the task of load-balancing between the several instances of the service.
      Nginx is a popular HTTP server and <a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank">load balancer</a>.
      To test load-balancing on my development box, I added the following to the local nginx configuration:

      <div class="prog">
        <pre><code>
http {
    upstream localhost {
        server localhost:8000;
        server localhost:8002;
    }

    server {
        listen 8080;

        location / {
            proxy_pass http://localhost;
        }
    }
}
        </code></pre>            
      </div>

    <p>The above configuration basically means nginx will accept connections on port 8080 and forward those
      to one of the service instances running on port 8000 and 8002 of the same machine. The load-balancing method will
      be round-robin, which is the default.</p>
    
    <p>Start two instances of the URL shortener, one on port 8000 and the other on 8002 and restart nginx.
      The calls for <code>POST http://localhost:8080</code> and <code>GET http://localhost:8080/:hash</code>
      will be distributed between the two instances by nginx. To scale the service, start new instances
      and add them to the <code>upstream</code> configuration.</p>

    <h3>Conclusion</h3>
    <p>Spark provides a simple and clean interface for writing HTTP based services that can be easily integrated with any
      language running on the JVM. Adding a functional wrapper on top of its basic interface definitely makes it more appealing for
      server-side development in Clojure.</p>
    
    <hr></hr>
  </body>
</html>
